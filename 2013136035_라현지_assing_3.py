
# coding: utf-8

# ## 2013136035 라현지 assignment_3 

# ### 1.  L=[1, 2, 3, 4, 5]일 때 다음 각 문장을 수행한 후의 결과를 보고 납득할 만한 이유를 설명하시오.
# 
# 

# In[29]:

L=[1, 2, 3, 4, 5]
L[1:3] = [100]  
print L  


# L[1:3] = [100]의 수행결과 이유
# > 리스트는 문자열과 달리, 내용을 바꿀 수 있다.L[1:3]d은 L[1]과 L[2]를 합친 크기에 [100]이라는 원소 한 개의 크기를 넣는 것이다. 결국 두 크기를 하나의 크기로 바꾸기 때문에 전체 크기가 4이고 100으로 바뀐 리스트가 출력된다.

# In[16]:

L=[1, 2, 3, 4, 5]
L[1:3] = [(100)]  
print L  


# L[1:3] = [(100)]의 수행결과 이유
# > (100)을 type((100))으로 출력해보면 int 자료형이 나온다. 100과 (100)은 같은 int형으로 자료형이 같다. 둘은 같기 때문에  [(100)]을 해도  
# L[1:3] = [100]의 결과와 같은 결과가 출력된다.

# In[24]:

L=[1, 2, 3, 4, 5]
L[1:3] = 100
print L  


# L[1:3] = 100 의 수행결과 이유
# > 파이썬에서는  str, range, list, tuple, dict, set 들을 iterable 자료형이라고 한다. 오류에서 처럼 iterable 자료형만 할당이 가능하기 때문에 
# 100은 int 자료형이라 오류가 생긴다.

# In[18]:

L=[1, 2, 3, 4, 5]
L[1:3] = (100)  
print L  


# L[1:3] = (100) 의 수행결과 이유
# > 파이썬에서는 str, range, list, tuple, dict, set 들을 iterable 자료형이라고 한다. 오류에서 처럼 iterable 자료형만 할당이 가능하기 때문에 (100)은 int 자료형이라 오류가 생긴다.

# In[25]:

L=[1, 2, 3, 4, 5]
L[1:3] = (100, 101, 102)  
print L  


#  L[1:3] = (100, 101, 102) 의 수행결과 이유
#  > (100, 101, 102)의 자료형은 tuple이며  iterable 자료형이기 때문에 할당이 가능하다. L[1],L[2]의 크기를 (100, 101, 102)의 크기로 바껴야 하기 때문에 전체 크기가 증가한 리스트가 출력된다.

# In[20]:

L=[1, 2, 3, 4, 5]
L[1:3] = [100, 101, 102]  
print L  


#  L[1:3] = [100, 101, 102] 의 수행결과 이유
#  > [100, 101, 102]의 자료형은 리스트이며  iterable 자료형이기 때문에 할당이 가능하다. L[1],L[2]의 크기를 [100, 101, 102]의 크기로 바껴야 하기 때문에 전체 크기가 증가한 리스트가 출력된다. 위의 이유와 동일.

# In[28]:

L=[1, 2, 3, 4, 5]
L[1:3] = [(100, 101, 102)]  
print L  


# L[1:3] = [(100, 101, 102)] 의 수행결과 이유
# > [(100, 101, 102)]의 리스트 안에는 튜플 (100, 101, 102)이 있다. 하나의 리스트안에 튜플이 있는 것이다.  L[1],L[2]에 하나의 리스트를 넣는 것이기 때문에 원소 한 개로 취급 되기 때문에 전체 크기가 4이고 (100, 101, 102)를 하나의 원소로 가지는 리스트가 출력된다.

# In[22]:

L=[1, 2, 3, 4, 5]
L[1:3] = [[100, 101, 102]]  
print L  


# L[1:3] = [[100, 101, 102]] 의 수행결과 이유
# > [[100, 101, 102]]의 리스트 안에는 리스트 [100, 101, 102]이 있다. 하나의 리스트안에 튜플이 있는 것이다. L[1],L[2]에 하나의 리스트를 넣는 것이기 때문에 원소 한 개로 취급 되기 때문에 전체 크기가 4이고 [100, 101, 102]를 하나의 원소로 가지는 리스트가 출력된다.

# ### 2. 문자열 S = 'Hello World and Python'에 대해 다음 요구사항에 대한 Python 코드를 제시하시오.
# 1) 단어의 순서가 역순으로 되어진 문자열 ('Python and World Hello')을 만들고  
# 2) 1)의 결과 문자열에 대해 메소드 split과 join을 이용하여 공백을 모두 없엔 문자열 'PythonandWorldHello'을 만드시오.

# In[41]:

S = 'Hello World and Python'
S_split = S.split()
S_new= ''
for i in S_split[::-1]:
    S_new = S_new + i +' '
print S_new

S_new = S_new.split()
print ''.join(S_new)
        


# ### 2번 문제 코드 설명
# > 먼저 S의 문자열을 split 함수로 단어를 분리하여 리스트로 만들어서 S_split 변수에 할당하고, S_split를 반복문을 사용하여 거꾸로 돌린다. 반복문이 한번 지날 때 마다 S_new 변수에 단어 한 개와 공백이 새로 할당이 되어 역순으로 되어진 문자열이 출력된다.
# > 그리고 S_new 변수를 다시 split 함수로 단어별로 나누고 join 함수를 사용하여 공백이없는 역순 문자열을 출력한다.

# ### 3. 다음 코드를 보고 물음에 답하시오.
# 
# >a = [1, 2, 3]  
# b = a \* 3  
# c = [a] \* 3  
# print b  
# print c  
# 1) 위 코드를 수행한 이후 다음 코드를 수행한 후 b와 c의 내용을 확인하시오.  
# a[0]=0  
# 2) b와 c 객체의 차이는 무엇인가?  

# In[66]:

a = [1, 2, 3]
b = a * 3
c = [a] *3
print b
print c
a[0] =0
print b
print c


# ### 3번 문제 설명
# > b와 c의 객체의 차이  
# > a[0] =0 실행 이후, b의 출력값은 변함이 없고 c의 출력값은 a[0] =0가  적용되었다.  
# 

# ### 4.  다음 문자열을 ':'을 기준으로 분리하여 리스트로 만들고 각 문자열의 좌우 공백을 제거하시오 (즉, 문자열 S에서 l을 만들어라)
# > s = '  first star   :   second star   :    third star  '  
# l = ['first star', 'second star', 'third star']  
# 1) for ~ in 문을 이용한 코드를 작성하시오.  
# 2) 리스트 내포(list comprehension)를 이용한 코드를 작성하시오.  

# In[75]:

# 1) for ~ in 사용
s = '  first star   :   second star   :    third star  '
s = s.split(':')
I = []
for i in s:
    I.append(i.strip())
print I

# 2) 리스트 내포 사용
s = '  first star   :   second star   :    third star  '
s = s.split(':')
l = [i.strip() for i in s]
print l


# ### 5. 다음과 같이 0보다 큰 정수 리스트 변수 list를 인자로 받는 함수 addall(list)와 addallodd(list)를 for ~ in 리터널과 리스트 내포 방식으로 각각 제시하시오.
# 1) addall(list) 함수 (리스트 내의 모든 정수를 더하는 함수로서 해답으로는 for ~ in 리터럴과 리스트 내포 방식으로 각각 제시하시오.)  
# \>>> addall([1])  
# 1  
# \>>> addall([1, 2, 3, 4, 5, 6, 7, 8, 9])  
# 45  
# 2) addallodd(list) 함수 (리스트내의 모든 홀수를 더하는 함수로서 해답으로는 for ~ in 리터럴과 리스트 내포 방식으로 각각 제시하시오.)  
# \>>> addallodd([1])  
# 1  
# \>>> addallodd([1, 2, 3, 4, 5, 6, 7, 8, 9])  
# 25  
# [참고 1]: 리스트 내포 방식으로 addall() 및 addallodd()함수를 만들 때엔 리스트 내포에 의해 생성된 리스트 결과에 대해 내장 함수를 사용하는 방식을 고려해보시오 (주의: 리스트 내포 방식의 addall() 및 addallodd() 함수의 몸체는 단 1줄로 작성되어야 한다.)  
# [참고 2]: sum() 등의 내장함수 사용 가능함  

# In[88]:

# 1) for ~ in 사용
def addall(list):
    sum = 0
    for i in list:
        sum = sum + i
    return sum

print addall([1, 2, 3, 4, 5, 6, 7, 8, 9])

# 1) 리스트 내포 사용

def addall(list):
   return sum([i for i in list])

print addall([1, 2, 3, 4, 5, 6, 7, 8, 9])


# In[93]:

# 2) for ~ in 사용
def addallodd(list):
    sum = 0
    for i in list:
        if(i%2 == 1):
            sum = sum + i
    return sum

print addallodd([1, 2, 3, 4, 5, 6, 7, 8, 9])

# 2) 리스트 내포 사용

def addallodd(list):
   return sum([i for i in list if (i%2) == 1] )

print addallodd([1, 2, 3, 4, 5, 6, 7, 8, 9])


# ### 6. 다음 코드를 보고 물음에 답하시오.

# In[108]:

L1 = [1, 2, 3]  
L2 = [4, 5, 6]  
d = {'low':L1, 'high':L2}  
e = d  
f = d.copy()  

print d  
print e  
print f  
print 
d['low'] = [10, 20, 30]  
d['high'][1] = 500

print d  
print e  
print f  


# 1) 위 코드의 수행 결과 d와 e는 항상 같은 결과를 출력한다. 그 이유는 무엇인가?  
# > d와 e의 id 값이 같기 때문이다. 
# 
# 
# 2) 위 코드의 수행 결과 마지막 f의 내용은 다음과 같다. 이 때 'high' 키의 값 내용 중 500이 출력된 이유와 'low' 키의 값 내용 중 [1, 2, 3]이 출력된 이유를 설명하시오 ([hint]: shallow copy 관점에서 설명하시오.)  
# > d와 f는 id 값이 다른 서로 다른 객체이지만  d['low']와 f['low']의 id는 같다. 이유는 shallow copy 특성상 f는 d를 copy해서 f와 d의 id값은 달라도 d가 가리키는 자료형인 dict이나 list의 id값은 f와 d가 같다.(하지만 상수는 전혀다르다. 파이썬 특징임) 그런데 d['low'] = [1,2,3] 에서 [10,20,30]으로 바꾸면 전혀 다른 리스트의 id를 참조하게 된다. 하지만 f는 전혀 바꾸지 않은 상태이기 때문에 그대로 [1,2,3]을 참조하게 된다.   
# 그런데 high 키의 값 500이 출력된 이유는 d['high'][1]의 id 값과 f['high'][1]의 id 값이 같기 때문에 수정을해도 같다

# ### 7. 사전 d = {'one':1, 'two':2, 'three':3, 'four':4, 'five':5}가 주어졌을 때 다음 요구사항에 맞는 코드를 제시하시오
# > [참고]: d.keys(), d.values()를 통해 리스트를 얻어낸 후 리스트가 지니고 있는 sort(cmp=None, key=None, reverse=False)함수를 활용하시오.  
# 
# > 1) 키의 알파벳 오름차순 순서대로 튜플 (키, 값)을 차례대로 출력하시오.  
# 2) 키의 알파벳 내림차순 순서대로 튜플 (키, 값)을 차례대로 출력하시오.  
# 3) 값의 오름차순 순서대로 튜플 (키, 값)을 차례대로 출력하시오.  
# 4) 값의 내림차순 순서대로 튜플 (키, 값)을 차례대로 출력하시오.  

# In[128]:

d = {'one':1, 'two':2, 'three':3, 'four':4, 'five':5}
keylist = d.keys()
valuelist = d.values()

# 키의 알파벳 오름차순 순서대로 튜플 (키, 값)을 차례대로 출력
keylist.sort()
for k in keylist:
    print tuple((k,d[k])),

print 
#키의 알파벳 내림차순 순서대로 튜플 (키, 값)을 차례대로 출력
keylist.sort(reverse = True)
for k in keylist:
    print tuple((k,d[k])),
    
#값의 오름차순 순서대로 튜플 (키, 값)을 차례대로 출력   
print
valuelist.sort()
new = ()
for v in valuelist:
     for k in d:
            if v == d[k]:
                print (k,v),
                
#값의 내림차순 순서대로 튜플 (키, 값)을 차례대로 출력   
print
valuelist.sort(reverse = True)
new = ()
for v in valuelist:
     for k in d:
            if v == d[k]:
                print (k,v),



# ### 오일러 문제 7번
# >소수를 크기 순으로 나열하면 2, 3, 5, 7, 11, 13, ... 과 같이 됩니다.   
# 이 때 10,001번째의 소수를 구하세요.

# In[37]:

import math
i = 3
count = 2
while(count < 10001):
    i = i+2
    n = int(math.sqrt(i))
    for j in range(2,n+1):
        if(i%j == 0):
            break
    else:
        count = count +1
        
    
print i
    


# #### 코드 설명
# > 빠른 속도를 위해서 판별하려는 수 i의 제곱근까지 j를 2부터 나누어서 소수를 판단한다. 
# 이때, 소수 중, 2를 제외한 모든 수들은 홀수이니까 i= i+2를 해서 3부터는 홀수로만 소수를 판단한다. 또한 2는 명백히 소수라는것을 알기 때문에
# i의 초기값을 3으로 먼저 시작하고 count 변수는 소수가 세어질 때마다 1씩 올라가는데 count =1은 소수 2, count =2는 소수 3을 뜻한다. 그래서 count의 초기값을 2로 먼저 시작한다. ( i의 초기값이 3이기 때문..)

# ### 오일러 문제 8번
# 다음은 연속된 1000자리 숫자입니다 (읽기 좋게 50자리씩 잘라놓음).  
# 
# 73167176531330624919225119674426574742355349194934  
# 96983520312774506326239578318016984801869478851843  
# 85861560789112949495459501737958331952853208805511  
# 12540698747158523863050715693290963295227443043557  
# 66896648950445244523161731856403098711121722383113  
# 62229893423380308135336276614282806444486645238749  
# 30358907296290491560440772390713810515859307960866  
# 70172427121883998797908792274921901699720888093776  
# 65727333001053367881220235421809751254540594752243  
# 52584907711670556013604839586446706324415722155397  
# 53697817977846174064955149290862569321978468622482  
# 83972241375657056057490261407972968652414535100474  
# 82166370484403199890008895243450658541227588666881  
# 16427171479924442928230863465674813919123162824586  
# 17866458359124566529476545682848912883142607690042  
# 24219022671055626321111109370544217506941658960408  
# 07198403850962455444362981230987879927244284909188  
# 84580156166097919133875499200524063689912560717606  
# 05886116467109405077541002256983155200055935729725  
# 71636269561882670428252483600823257530420752963450  
# 
# 여기서 붉게 표시된 71112의 경우 7, 1, 1, 1, 2 각 숫자를 모두 곱하면 14가 됩니다.  
# 
# 이런 식으로 맨 처음 (7 × 3 × 1 × 6 × 7 = 882) 부터 맨 끝 (6 × 3 × 4 × 5 × 0 = 0) 까지 5자리 숫자들의 곱을 구할 수 있습니다.  
# 이렇게 구할 수 있는 5자리 숫자의 곱 중에서 가장 큰 값은 얼마입니까?

# In[49]:

s = '7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450'

temp = 1
max = 0
for key,v in enumerate(s):
    
    if (key+5) > len(s):
        break
        
    for z in s[key:key+5]:
        temp = temp * int(z)
    if max <= temp:
        max = temp
    temp = 1
    
print max 


# #### 코드설명
# > s 변수에 주어진 수들을 문자열 형식으로 넣는다. 그리고 반복문을 통해서 enumerate를 사용하여 문자열 s의 키와 값을 알아낸다. 그 안에 또 반복문을 사용하여 해당 key 부터 key+5 까지의 수들을 정수로 바꾸고 temp에 곱해서 다시 temp에 넣는다. 반복문이 끝나면 max에 최대값인지 판단하고 최대값이면 max 변수에 넣는다. key+5 값이 문자열 s의 전체 길이보다 커지면 반복문을 끝내고 max를 출력한다. 

# ### 오일러 문제 9번
# >세 자연수 a, b, c 가 피타고라스 정리 a^2 + b^2 = c^2 를 만족하면 피타고라스 수라고 부릅니다 (여기서 a < b < c ).  
# 예를 들면 3^2 + 4^2 = 9 + 16 = 25 = 5^2이므로 3, 4, 5는 피타고라스 수입니다.
# 
# >a + b + c = 1000 인 피타고라스 수 a, b, c는 한 가지 뿐입니다. 이 때, a × b × c 는 얼마입니까?

# In[62]:

for a in range(1,354):
    for b in range(354,499):
        for c in range(355,500):
            if((pow(a,2) + pow(b,2)) == pow(c,2)) and ((a+b+c) == 1000):
                print 'a:', a ,'   b:', b ,'   c:', c
                print 'answer: ',a*b*c 
                break
    
        
        


# #### 코드설명
# > 문제에서 나온 조건들 4가지를 이용해서 a,b,c의 범위를 좁혀야한다.  
#  1)  a^2 + b^2 = c^2   
#  2) a < b < c   
#  3) a + b + c = 1000   
#  4) a+b > c  (삼각형 형성조건: 두변의 길이 합이 나머지 변의 길이보다 크다)  
#  
# > 3번식에서 a+b = 1000-c , 여기에 4번을 적용하면   
# 1000 -c > c  
# 1000 > 2c  
# c < 500 이라고 범위가 좁혀진다.    
# 
# > 1번 식에서  a^2 + b^2 = c^2  , 여기에 c< 500을 적용하면  
#  a^2 + b^2 < 500^2 , 여기에 2번 식인 a < b < c 를 적용하면 a는 항상 b보다 작다. 그렇기 때문에 최소한 a^2와 b^2는 (500^2)/2 를 기준으로
#  부등호가 갈리며   
#  a^2 < (500^2)/2 < b^2   
#  a < 루트(500^2/2) <b  
#  루트(500^2/2) ≒ 353.55339  
#  1 <= a <= 353
#  353 < b <  c < 500  이라는 범위가 나온다
#  
# > a의 초기값은 1 , 최대값은 b-1 즉, 353  
# > b의 초기값은 354, 최대값은 c-1  
# > c의초기값은 355 ,최대값은 500-1
#    
#  
#  
# 
# 
#  
#  
#  
#  

# ### [Incremental Project] 
# ### naver ,다음, nytimes

# In[87]:


# naver 홈페이지
import string
import urllib2
# source 변수에 페이지 소스를 읽어온다.
source = urllib2.urlopen("http://www.naver.com").read()
# 읽어온 페이지의 줄띄움, 탭, 빈 공간을 모두 없애주고 한줄로 깔끔하게 정리한다.
source = source.replace('\n','')
source =  source.replace('\t','')
new=[]
dic = dict()

while 1:
    # <의 위치값
    start = source.find('<')
    # >의 위치값은 항상 <보다 커야한다. 그래야 html 태그라고 볼 수 있다.
    end = source.find('>',start)
    
    # html 태그가 아닌 순수한 문자열 중에서도 <와 >가 있을 수 있다. 그것을 구분하기 위한 코드이다.
    # html 태그라면 <의 위치값이 >의 위치값 보다 항상 낮다. 만약 크다면 순수한 문자열이라고 볼 수 있다.
    if (start-end) >= 1 :
        continue     
    
    # html 태그가 맞다면 태그 부분을 빈 공간으로 대체한다.
    if ( start != -1) and (end != -1):
        source =  source.replace(source[start:end+1]," ")       
    
    # html 태그를 모두 찾고 더이상 없으면 반복문을 종료
    if ( start == -1) and (end == -1):
        break
        
new = source.split()
for i,s in enumerate(new):
    for k in s:
        if k in string.punctuation:
            s= s.replace(k,'')
    else :
        new[i] = s

        
for i,n in enumerate(new):
    if new[i] == '':
        del new[i]
        
for n in new:
    dic[n]= new.count(n)

for key in dic:
    print '{',key,':',dic[key],'}   ',






# In[88]:


#  daum 홈페이지
import string
import urllib2
# source 변수에 페이지 소스를 읽어온다.
source = urllib2.urlopen("http://www.daum.net").read()
# 읽어온 페이지의 줄띄움, 탭, 빈 공간을 모두 없애주고 한줄로 깔끔하게 정리한다.
source = source.replace('\n','')
source =  source.replace('\t','')
new=[]
dic = dict()

while 1:
    # <의 위치값
    start = source.find('<')
    # >의 위치값은 항상 <보다 커야한다. 그래야 html 태그라고 볼 수 있다.
    end = source.find('>',start)
    
    # html 태그가 아닌 순수한 문자열 중에서도 <와 >가 있을 수 있다. 그것을 구분하기 위한 코드이다.
    # html 태그라면 <의 위치값이 >의 위치값 보다 항상 낮다. 만약 크다면 순수한 문자열이라고 볼 수 있다.
    if (start-end) >= 1 :
        continue     
    
    # html 태그가 맞다면 태그 부분을 빈 공간으로 대체한다.
    if ( start != -1) and (end != -1):
        source =  source.replace(source[start:end+1]," ")       
    
    # html 태그를 모두 찾고 더이상 없으면 반복문을 종료
    if ( start == -1) and (end == -1):
        break
        
new = source.split()
for i,s in enumerate(new):
    for k in s:
        if k in string.punctuation:
            s= s.replace(k,'')
    else :
        new[i] = s

        
for i,n in enumerate(new):
    if new[i] == '':
        del new[i]
        
for n in new:
    dic[n]= new.count(n)

for key in dic:
    print '{',key,':',dic[key],'}   ',






# In[92]:


# nytimes 홈페이지
import string
import urllib2
# source 변수에 페이지 소스를 읽어온다.
source = urllib2.urlopen("http://www.nytimes.com").read()
# 읽어온 페이지의 줄띄움, 탭, 빈 공간을 모두 없애주고 한줄로 깔끔하게 정리한다.
source = source.replace('\n','')
source =  source.replace('\t','')
new=[]
dic = dict()

while 1:
    # <의 위치값
    start = source.find('<')
    # >의 위치값은 항상 <보다 커야한다. 그래야 html 태그라고 볼 수 있다.
    end = source.find('>',start)
    
    # html 태그가 아닌 순수한 문자열 중에서도 <와 >가 있을 수 있다. 그것을 구분하기 위한 코드이다.
    # html 태그라면 <의 위치값이 >의 위치값 보다 항상 낮다. 만약 크다면 순수한 문자열이라고 볼 수 있다.
    if (start-end) >= 1 :
        continue     
    
    # html 태그가 맞다면 태그 부분을 빈 공간으로 대체한다.
    if ( start != -1) and (end != -1):
        source =  source.replace(source[start:end+1]," ")       
    
    # html 태그를 모두 찾고 더이상 없으면 반복문을 종료
    if ( start == -1) and (end == -1):
        break
        
new = source.split()
for i,s in enumerate(new):
    for k in s:
        if k in string.punctuation:
            s= s.replace(k,'')
    else :
        new[i] = s

        
for i,n in enumerate(new):
    if new[i] == '':
        del new[i]
        
for n in new:
    dic[n]= new.count(n)

print dic






# ### 소감문
# > 임플리먼트 숙제 말입니다......파이썬 한글이 정말 너무 인코딩이 진짜 너무 안되서 사전 출력할 때 원소 하나하나 루프 돌면서 출력했습니다. 마지막 nytimes는 온통 영어 페이지라서 그냥 사전 자체를 출력했습니다. 

# In[ ]:



